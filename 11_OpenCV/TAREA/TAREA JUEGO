import pygame
import random
import cv2
import sys

# === ConfiguraciÃ³n ===
pygame.init()
WIDTH, HEIGHT = 400, 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Face Jump ðŸª‚")
clock = pygame.time.Clock()

# Jugador
player_x = WIDTH // 2
player_y = HEIGHT - 100
player_width, player_height = 40, 40
player_velocity_y = 0
GRAVITY = 0.5
JUMP_FORCE = -12
BOOST_FORCE = -20

# Plataformas
platforms = []
PLATFORM_WIDTH = 60
PLATFORM_HEIGHT = 15
NUM_PLATFORMS = 8

# Colores
WHITE = (255, 255, 255)
GREEN = (50, 200, 50)
BLUE = (50, 50, 200)
RED = (200, 50, 50)

# === OpenCV ===
cap = cv2.VideoCapture(0)
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")

def init_platforms():
    global platforms
    platforms = []
    step = HEIGHT // NUM_PLATFORMS
    for i in range(NUM_PLATFORMS):
        x = random.randint(50, WIDTH-50)
        y = HEIGHT - i*step - 50
        booster = random.random() < 0.2  # 20% chance booster
        platforms.append([x, y, booster])

def detect_face_controls(frame):
    global player_x
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = face_cascade.detectMultiScale(gray, 1.3, 5)

    for (x, y, w, h) in faces:
        cx = x + w//2
        # Mapear al ancho del juego (espejo ON)
        player_x = int((cx / frame.shape[1]) * WIDTH)

def draw_game(frame):
    # Fondo cÃ¡mara
    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    frame_rgb = cv2.resize(frame_rgb, (WIDTH, HEIGHT))
    surf = pygame.surfarray.make_surface(frame_rgb.swapaxes(0, 1))
    screen.blit(surf, (0, 0))

    # Plataformas
    for plat in platforms:
        color = BLUE if plat[2] else GREEN
        pygame.draw.rect(screen, color, (plat[0], plat[1], PLATFORM_WIDTH, PLATFORM_HEIGHT))

    # Jugador
    pygame.draw.rect(screen, RED, (player_x - player_width//2, player_y, player_width, player_height))

    pygame.display.flip()

def reset_game():
    global player_x, player_y, player_velocity_y
    player_x = WIDTH // 2
    player_y = HEIGHT - 100
    player_velocity_y = 0
    init_platforms()

# === Inicio ===
init_platforms()

# === Bucle principal ===
game_over = False
while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            cap.release()
            pygame.quit()
            sys.exit()

        if game_over:
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_r:
                    reset_game()
                    game_over = False
                elif event.key == pygame.K_q:
                    cap.release()
                    pygame.quit()
                    sys.exit()

    ret, frame = cap.read()
    if not ret:
        break

    frame = cv2.flip(frame, 1)  # espejo
    if not game_over:
        detect_face_controls(frame)

        # Gravedad
        player_velocity_y += GRAVITY
        player_y += player_velocity_y

        # Colisiones con plataformas
        player_rect = pygame.Rect(player_x - player_width//2, player_y, player_width, player_height)
        for plat in platforms:
            plat_rect = pygame.Rect(plat[0], plat[1], PLATFORM_WIDTH, PLATFORM_HEIGHT)
            if player_rect.colliderect(plat_rect) and player_velocity_y > 0:
                player_velocity_y = BOOST_FORCE if plat[2] else JUMP_FORCE

        # Scroll: plataformas suben cuando jugador sube
        if player_y < HEIGHT//2:
            offset = HEIGHT//2 - player_y
            player_y = HEIGHT//2
            for plat in platforms:
                plat[1] += offset
            # Nuevas plataformas
            while len(platforms) < NUM_PLATFORMS:
                x = random.randint(50, WIDTH-50)
                y = random.randint(-50, 0)
                booster = random.random() < 0.2
                platforms.append([x, y, booster])
            # Eliminar plataformas fuera
            platforms = [p for p in platforms if p[1] < HEIGHT]

        # Game over si cae
        if player_y > HEIGHT:
            game_over = True

    draw_game(frame)
    clock.tick(30)